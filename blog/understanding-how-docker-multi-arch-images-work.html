<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="description" content="Innovation driven and quality focused engineering team to help you in your most challenging tasks. Contact us on hello@icetek.io to learn more!"/><meta name="theme-color" content="#53E7FF"/><link rel="canonical" href="https://icetek.io/"/><link rel="apple-touch-icon" sizes="57x57" href="/images/favicon/apple-icon-57x57.png"/><link rel="apple-touch-icon" sizes="60x60" href="/images/favicon/apple-icon-60x60.png"/><link rel="apple-touch-icon" sizes="72x72" href="/images/favicon/apple-icon-72x72.png"/><link rel="apple-touch-icon" sizes="76x76" href="/images/favicon/apple-icon-76x76.png"/><link rel="apple-touch-icon" sizes="114x114" href="/images/favicon/apple-icon-114x114.png"/><link rel="apple-touch-icon" sizes="120x120" href="/images/favicon/apple-icon-120x120.png"/><link rel="apple-touch-icon" sizes="144x144" href="/images/favicon/apple-icon-144x144.png"/><link rel="apple-touch-icon" sizes="152x152" href="/images/favicon/apple-icon-152x152.png"/><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-icon-180x180.png"/><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon/android-icon-192x192.png"/><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon/favicon-96x96.png"/><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png"/><link rel="manifest" href="manifest.json"/><link rel="preload" href="/fonts/iceGX.ttf" as="font" type="font/ttf" crossorigin="anonymous"/><link rel="preload" href="/fonts/Icetek_newGX.ttf" as="font" type="font/ttf" crossorigin="anonymous"/><link rel="preload" href="/fonts/3B1CDA_E_0.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/3B1CDA_4_0.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/fonts/3B1CDA_1_0.woff2" as="font" type="font/woff2" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/76b3265020c70ebb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/76b3265020c70ebb.css" data-n-g=""/><link rel="preload" href="/_next/static/css/aa285a68ac3ec529.css" as="style"/><link rel="stylesheet" href="/_next/static/css/aa285a68ac3ec529.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer=""></script><script src="/_next/static/chunks/framework-7751730b10fa0f74.js" defer=""></script><script src="/_next/static/chunks/main-e7a7892cb0edc024.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2a8e5afe453b1c5e.js" defer=""></script><script src="/_next/static/chunks/6-3639b914583b3f49.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-e45dee4b97f1c17a.js" defer=""></script><script src="/_next/static/qXuR2Q6U2o4nVcHdlp6Hy/_buildManifest.js" defer=""></script><script src="/_next/static/qXuR2Q6U2o4nVcHdlp6Hy/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="navbar navbar-expand-lg navbar-light bg-white fixed-top"><a class="navbar-brand" href="/"><picture><img src="/images/logo.jpg" width="auto" height="100%" alt="Home"/></picture></a><button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarContent" aria-controls="navbarContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 17 17" class="show-menu-icon nav-icon" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><g></g><path d="M16 3v2h-15v-2h15zM1 10h15v-2h-15v2zM1 15h15v-2h-15v2z"></path></svg><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 17 17" class="hide-menu-icon nav-icon" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><g></g><path d="M9.207 8.5l6.646 6.646-0.707 0.707-6.646-6.646-6.646 6.646-0.707-0.707 6.646-6.646-6.647-6.646 0.707-0.707 6.647 6.646 6.646-6.646 0.707 0.707-6.646 6.646z"></path></svg></span></button><div id="navbarContent" class="collapse navbar-collapse"><ul class="navbar-nav mr-auto"><li class="nav-item active"><a class="nav-link" href="/">Home</a></li><li class="nav-item "><a class="nav-link" href="/products">Products</a></li><li class="nav-item "><a class="nav-link" href="/services">Services</a></li><li class="nav-item "><a class="nav-link" href="/contact">Contact</a></li><li class="nav-item active"><a class="nav-link" href="/blog">Blog</a></li></ul></div></header><div class="container"><div class="row"><div class="col-lg-10 m-auto"><div class="card-page"><div class="my-10"><div class="row"><div class="col-2"><picture><img class="card-img-top rounded-circle" src="/blog-images/jakub-czaplinski.jpeg" alt="..."/></picture></div><div class="col align-self-center "><div class=" align-middle"><h6 class="small text-muted">Jakub Czapliński</h6><div class="small text-muted">23/4/2020</div></div></div></div></div><a href="/blog/understanding-how-docker-multi-arch-images-work"><picture><img class="card-img-top" src="/blog-images/multi-arch-header-img.jpeg" alt="..."/></picture></a><h1 class="card-title my-10">Understanding How Docker Multi-arch Images Work</h1><div class="post-body my-10"><p>With the constantly rising popularity of IoT and Edge computing ARM architecture is gaining a lot of popularity. Not only phones are now equipped with ARM processors but also small single board computers. The most popular example is of course is the beloved and super popular Raspberry Pi, however there are a lot more devices designed for makers in mind, like the NVIDIA Jetson family, Khadas VIM, Rock Pi to name a few. Because of that, the need to build, test and run code both natively and in Docker containers on various architectures is bigger than ever.</p>
<h2 id="why-should-i-bother">Why should I bother?</h2>
<p>In this article I want to show how to build and store our images for different architectures so that they behave like - for example - the <code>python</code> image which you can run on almost any architecture just by running <code>docker run -it python:3.8</code>.</p>
<p>If you want to follow along I have prepared a repository with source code, all the commands, Dockerfiles and everything you need to do to run similar tests. You can work on your hardware as long as you can run Docker on it and the architecture is supported by Python, which you can check on picture below. The repository can be found here</p>
<h2 id="mission-objectives">Mission objectives</h2>
<p>Let&#39;s start by checking what can we find about the <code>python</code> image with <code>3.8</code> tags on the docker hub.</p>
<p><img src="/blog-images/python-supported-architectures.png" alt="python supported architectures"></p>
<p>As you can clearly see this image with this given tag is available for multiple architectures. Thanks to that I can run a simple python script on all of my test hardware.
My laptop:</p>
<pre><code class="language-bash">upgrade@ZeroOne ~ $ uname -a
Linux ZeroOne 4.15.0-36-generic #39~16.04.1-Ubuntu SMP Tue Sep 25 08:59:23 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux
upgrade@ZeroOne ~ $ docker run -it python:3.8 python -c &#39;print(&quot;Hello world!&quot;)&#39;
Hello world!
</code></pre>
<p>Raspberry Pi 4</p>
<pre><code class="language-bash">upgrade@rpi4:~ $ uname -a
Linux rpi4 4.19.97-v7l+ #1294 SMP Thu Jan 30 13:21:14 GMT 2020 armv7l GNU/Linux
upgrade@rpi4:~ $ docker run -it python:3.8 python -c &#39;print(&quot;Hello world!&quot;)&#39;
Hello world!
</code></pre>
<p>NVIDIA Jetson Nano:</p>
<pre><code class="language-bash">upgrade@jetson:~$ uname -a
Linux jetson 4.9.140-tegra #1 SMP PREEMPT Mon Dec 9 22:47:42 PST 2019 aarch64 aarch64 aarch64 GNU/Linux
upgrade@jetson:~$ docker run -it python:3.8 python -c &#39;print(&quot;Hello world!&quot;)&#39;
Hello world!
</code></pre>
<p>This portability is pretty awesome - we can develop python scripts that can run on a multitude of devices without a huge hassle. And what is more important, we do not have to worry about remembering which tag runs where. This is critical if we want to develop an application that will be run by external users - no one will be interested in digging through documentation to understand which tag they should choose based on their hardware. However, there is a catch as to how to make our images work the same way.</p>
<h2 id="understanding-the-problem">Understanding the problem</h2>
<p>I want to start by illustrating where the &quot;catch&quot; is so that I can later show how we can correctly solve the problem.</p>
<p>First thing first - we need a test subject. Time to build and test simple API that will return a hostname and equivalent of <code>uname -i</code></p>
<p>Docker build output:</p>
<pre><code class="language-bash">upgrade@ZeroOne ~/src/python/multi-arch-python $ docker build -t icetekio/nodeinfo:fixedarch .
Sending build context to Docker daemon    108kB
Step 1/5 : FROM python:3.8
...
trimmed output
...
Digest: sha256:3df040cc8e804b731a9e98c82e2bc5cf3c979d78288c28df4f54bbdc18dbb521
...
trimmed output
...
Successfully built 9185b3dffa7a
Successfully tagged icetekio/nodeinfo:fixedarch
</code></pre>
<p>Docker push:</p>
<pre><code class="language-bash">upgrade@ZeroOne ~/src/python/multi-arch-python $ docker push icetekio/nodeinfo:fixedarch
The push refers to repository [docker.io/icetekio/nodeinfo]
...
trimmed output
...
fixedarch: digest: sha256:486ec9f38ecfc476e7abe911031bf8ea4a7c605716b35c490b5cf524ef0c3d12 size: 2635
</code></pre>
<p>And let&#39;s see how it looks on the docker hub.</p>
<p><img src="/blog-images/architecture-of-the-nodetool-fixedarch.png" alt="architecture-of-the-nodetool-fixedarch"></p>
<p>Cool! We have the image, and as you can see in my case it is <em>linux/amd64</em> and it makes kind of sense as if you remember the output of <code>uname -a</code> on my machine was</p>
<pre><code class="language-bash">Linux ZeroOne 4.15.0-36-generic #39~16.04.1-Ubuntu SMP Tue Sep 25 08:59:23 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux
</code></pre>
<p>and we need to remember that often x86_64 and amd64 are used to represent this architecture.</p>
<p>The quote &quot;The nice thing about standards is that you have so many to choose from&quot; from, I think, Andrew S. Tanenbaum fits here pretty nicely.</p>
<p>Now I can run the application</p>
<pre><code class="language-bash">upgrade@ZeroOne ~ $ docker run --name nodeinfo -it -p 8080:8080 icetekio/nodeinfo:fixedarch
 * Serving Flask app &quot;app&quot; (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://0.0.0.0:8080/ (Press CTRL+C to quit)
</code></pre>
<p>and in the second terminal check if the app is working</p>
<pre><code class="language-bash">upgrade@ZeroOne ~ $ curl localhost:8080
{&quot;hostname&quot;:&quot;0b31ce6600f1&quot;,&quot;machine&quot;:&quot;x86_64&quot;}
</code></pre>
<p>OK, it seems everything is going accordingly to plan.</p>
<p>As we know Python is very portable, and we should be able to run our simple script on multitude of architectures. Well, Python is, but our image isn&#39;t. Remember when we looked at the Docker registry? When I&#39;m running the same command I get this nasty error.</p>
<p>NVIDIA Jetson Nano:</p>
<pre><code class="language-bash">upgrade@jetson:~$ docker run --name nodeinfo -it -p 8080:8080 icetekio/nodeinfo:fixedarch
standard_init_linux.go:211: exec user process caused &quot;exec format error&quot;
</code></pre>
<p>Raspberry Pi 4:</p>
<pre><code class="language-bash">upgrade@rpi4:~ $ docker run --name nodeinfo -it -p 8080:8080 icetekio/nodeinfo:fixedarch
standard_init_linux.go:211: exec user process caused &quot;exec format error&quot;
</code></pre>
<p>To understand better what happened we need to think about how docker builds the images. Simplifying, it takes the list of layers that are composing the base image - the <code>FROM python:3.8</code> from our example - and runs commands from Dockerfile on top of them. Every command is a new layer and then, it creates a new image manifest with the list of layers.</p>
<p>You can always review the layers on the Docker Hub UI. The Python image looks like this</p>
<p><img src="/blog-images/python-image-for-amd64-architecture-details.png" alt="python-image-for-amd64-architecture-details"></p>
<p>From here you can learn how every image is built. As you can also see, there is an architecture dropdown and images for different architectures may be built differently. And that is why when we built our image, it took as a base a very specific image. This image was designed for AMD64 architecture and will not work on hardware that is not compatible with this architecture. And what we want to do, is to have our image behave the same way - have a dropdown and be available on a multitude of platforms.</p>
<h2 id="building-on-a-different-architecture">Building on a different architecture</h2>
<p>It is time to build the same application on my Jetson Nano and push it to the registry.</p>
<p>Running the build on Jetson Nano will create image that is based on ARM64 Python image, and will have the same architecture in its manifest.</p>
<p>Docker build:</p>
<pre><code class="language-bash">upgrade@jetson:~/multi-arch-python$ docker build -t icetekio/nodeinfo:fixedarch .
Sending build context to Docker daemon    108kB
Step 1/5 : FROM python:3.8
3.8: Pulling from library/python
Digest: sha256:3df040cc8e804b731a9e98c82e2bc5cf3c979d78288c28df4f54bbdc18dbb521
Status: Downloaded newer image for python:3.8
 ---&gt; a42ce4e154a5
Step 2/5 : RUN pip install Flask==1.1.2
 ---&gt; Using cache
 ---&gt; e643716e3aae
Step 3/5 : EXPOSE 8080
 ---&gt; Using cache
 ---&gt; 74727b378afc
Step 4/5 : ADD app.py /app.py
 ---&gt; 346527755dc5
Step 5/5 : CMD [&quot;python&quot;, &quot;app.py&quot;]
 ---&gt; Running in 47dbd9c82e10
Removing intermediate container 47dbd9c82e10
 ---&gt; 2ef5c195cac4
Successfully built 2ef5c195cac4
Successfully tagged icetekio/nodeinfo:fixedarch
</code></pre>
<p>Docker run:</p>
<pre><code class="language-bash">upgrade@jetson:~/multi-arch-python$ docker push icetekio/nodeinfo:fixedarch
The push refers to repository [docker.io/icetekio/nodeinfo]
...
trimmed output
...
fixedarch: digest: sha256:f7cf076161876b4339d08ada1db9f39f818b743ecb2a8276c4512688e179e83d size: 2635
</code></pre>
<p>I have run the same test with the <code>curl</code> command on my Jetson Nano and it works perfectly. Let&#39;s look at the Docker hub and see how the images are described now.</p>
<p><img src="/blog-images/architecture-of-the-nodetool-fixedarch-next.png" alt="architecture-of-the-nodetool-fixedarch-next"></p>
<p>As you can see docker has overwritten the <code>fixedarch</code> tag and now only available image is on ARM64. When I will try to run it on my laptop which is AMD64 architecture or Raspberry Pi which is on ARM32 I will get familiar errors. So, we can build images for different architectures, but how to expose them under one tag?</p>
<h2 id="manifest-tool-to-the-rescue">Manifest tool to the rescue!</h2>
<p>There is a tool designed to resolve this problem written by Phil Estes. You can read more about it, and download it from here <a href="https://github.com/estesp/manifest-tool">https://github.com/estesp/manifest-tool</a> What we need to do now is to build all 3 images with different tags and then use this tool to create a multi architecture manifest and publish it on docker hub.</p>
<p>The easiest way to do it, is to push all 3 images with different tags and then merge them into the same tag. I choose to use <code>multiarch</code> as a tag, and add <code>-arch</code> suffix for every architecture that I will build the image.</p>
<p>Run the <code>docker build</code> on my laptop</p>
<pre><code class="language-bash">upgrade@ZeroOne ~/src/python/multi-arch-python $ docker build -t icetekio/nodeinfo:multiarch-amd64 .
...
trimmed output
...
Successfully tagged icetekio/nodeinfo:multiarch-amd64
</code></pre>
<p>and then <code>docker push</code></p>
<pre><code class="language-bash">upgrade@ZeroOne ~/src/python/multi-arch-python $ docker push icetekio/nodeinfo:multiarch-amd64
...
trimmed output
...
multiarch-amd64: digest: sha256:486ec9f38ecfc476e7abe911031bf8ea4a7c605716b35c490b5cf524ef0c3d12 size: 2635
</code></pre>
<p>I have repeated the process for Jetson Nano and Raspberry Pi 4, and after now we can verify images at the docker registry.</p>
<p><img src="/blog-images/multiple-images-build-for-specific-architecture.png" alt="multiple-images-build-for-specific-architecture"></p>
<p>Now we need to create a spec file in YAML format that we will pass to <code>manifest-tool</code> to create a multi architecture manifest glueing all images into one tag.</p>
<p>The YAML file should look like this:</p>
<pre><code class="language-yaml">image: icetekio/nodeinfo:multiarch
manifests:
  - image: icetekio/nodeinfo:multiarch-amd64
    platform:
      architecture: amd64
      os: linux

  - image: icetekio/nodeinfo:multiarch-arm32
    platform:
      architecture: arm
      os: linux

  - image: icetekio/nodeinfo:multiarch-arm64
    platform:
      architecture: arm64
      os: linux
</code></pre>
<p>Notice, that the architecture for ARM32 bit is actually <code>arm</code>. The values in manifest need to correspond to the values found in docker registry.</p>
<p>And now for the final step!</p>
<pre><code class="language-bash">upgrade@ZeroOne ~/src/python/multi-arch-python $ manifest-tool --debug push from-spec manifest.yaml
DEBU[0000] endpoints: [{false https://registry-1.docker.io v2 false true true 0xc000346600}]
DEBU[0000] repoName: icetekio/nodeinfo
INFO[0000] Retrieving digests of images...
DEBU[0000] authConfig for docker.io: mrupgrade
DEBU[0000] endpoints: [{false https://registry-1.docker.io v2 false true true 0xc000346780}]
DEBU[0000] Trying to fetch image manifest of docker.io/icetekio/nodeinfo repository from https://registry-1.docker.io v2
INFO[0002] Image &quot;icetekio/nodeinfo:multiarch-amd64&quot; is digest sha256:486ec9f38ecfc476e7abe911031bf8ea4a7c605716b35c490b5cf524ef0c3d12; size: 2635
DEBU[0002] authConfig for docker.io: mrupgrade
DEBU[0002] endpoints: [{false https://registry-1.docker.io v2 false true true 0xc000542d80}]
DEBU[0002] Trying to fetch image manifest of docker.io/icetekio/nodeinfo repository from https://registry-1.docker.io v2
INFO[0005] Image &quot;icetekio/nodeinfo:multiarch-arm32&quot; is digest sha256:c9ab7b7cd3c7b89bc611ce56368d6a4cbc6c27040e485839410e9c1ae8d4c9bf; size: 2635
DEBU[0005] authConfig for docker.io: mrupgrade
DEBU[0005] endpoints: [{false https://registry-1.docker.io v2 false true true 0xc000346f00}]
DEBU[0005] Trying to fetch image manifest of docker.io/icetekio/nodeinfo repository from https://registry-1.docker.io v2
INFO[0008] Image &quot;icetekio/nodeinfo:multiarch-arm64&quot; is digest sha256:f7cf076161876b4339d08ada1db9f39f818b743ecb2a8276c4512688e179e83d; size: 2635
DEBU[0008] Manifest list push url: https://registry-1.docker.io/v2/icetekio/nodeinfo/manifests/multiarch
DEBU[0008] mediaType of manifestList: application/vnd.docker.distribution.manifest.list.v2+json
DEBU[0008] authConfig for docker.io: mrupgrade
Digest: sha256:7eb4667ada05d0bc64686080c7dbc80edb1adf2405f7061db386df61e5ad778a 1050
</code></pre>
<p>Success!</p>
<p><img src="/blog-images/one-image-supporting-all-three-architectures.png" alt="one-image-supporting-all-three-architectures"></p>
<p>So now we know how to build images that users can use seamlessly on multiple architectures. Now this small app can run on all 3 devices and there is no need to worry about which tag to use - simply use the <code>multiarch</code> tag!</p>
<h2 id="final-thoughts">Final thoughts</h2>
<p>There is a lot more to preparing applications to run on every platform. In this example we used Python which by itself is portable. Most of the Python code can run anywhere without needing to port anything, and usually the only thing that user have to worry about is having Python interpreter available. Applications in other languages - especially the compiled ones - need to be written with portability in mind - and built on a given machine. Sometimes - like with Golang for example - the compiler offers cross compilation. Building applications on multiple architectures is actually massive topic, and I will try to cover more aspects of it, including how Docker can be used to help with this process in future articles.</p>
<p>If you are interested reading about my failures and lessons learned when I first try to port my application to ARM architecture you can read my Medium post found here <a href="https://medium.com/icetek/porting-iceci-to-arm-1d44850ef03f">https://medium.com/icetek/porting-iceci-to-arm-1d44850ef03f</a></p>
<h2 id="readout">Readout</h2>
<p>Multi architecture announcement on Docker blog: <a href="https://www.docker.com/blog/docker-official-images-now-multi-platform/">https://www.docker.com/blog/docker-official-images-now-multi-platform/</a></p>
<p>Blog post about multi architecture functionalities in docker: <a href="https://www.docker.com/blog/multi-arch-all-the-things/">https://www.docker.com/blog/multi-arch-all-the-things/</a></p>
<p>Manifest tool GitHub repository: <a href="https://github.com/estesp/manifest-tool">https://github.com/estesp/manifest-tool</a></p>
<p>IoT and Edge are pretty hot topics, so it&#39;s no wonder that many applications run on both ARM and x86 architectures. While dockerizing multiplatform applications it&#39;s a good idea to prepare multiplatform-aware images as well, as it can simplify a lot of things down the line and implementing this shouldn&#39;t introduce too much overhead. Jakub has prepared a write-up on building a multi-architecture image for a PC, NVIDIA Jetson Nano and a Raspberry Pi, you can check it out on our blog.</p>
</div></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"author":"Jakub Czapliński","authorPhoto":"jakub-czaplinski.jpeg","date":"2020-04-23T07:50:39Z","image":"multi-arch-header-img.jpeg","slug":"understanding-how-docker-multi-arch-images-work","summary":"With the constantly rising popularity of IoT and Edge computing ARM architecture is gaining a lot of popularity. Not only phones are now equipped with ARM processors but also small single board computers.","title":"Understanding How Docker Multi-arch Images Work"},"slug":"understanding-how-docker-multi-arch-images-work","content":"\nWith the constantly rising popularity of IoT and Edge computing ARM architecture is gaining a lot of popularity. Not only phones are now equipped with ARM processors but also small single board computers. The most popular example is of course is the beloved and super popular Raspberry Pi, however there are a lot more devices designed for makers in mind, like the NVIDIA Jetson family, Khadas VIM, Rock Pi to name a few. Because of that, the need to build, test and run code both natively and in Docker containers on various architectures is bigger than ever.\n\n## Why should I bother?\n\nIn this article I want to show how to build and store our images for different architectures so that they behave like - for example - the `python` image which you can run on almost any architecture just by running `docker run -it python:3.8`.\n\nIf you want to follow along I have prepared a repository with source code, all the commands, Dockerfiles and everything you need to do to run similar tests. You can work on your hardware as long as you can run Docker on it and the architecture is supported by Python, which you can check on picture below. The repository can be found here\n\n## Mission objectives\n\nLet's start by checking what can we find about the `python` image with `3.8` tags on the docker hub.\n\n![python supported architectures](/blog-images/python-supported-architectures.png)\n\nAs you can clearly see this image with this given tag is available for multiple architectures. Thanks to that I can run a simple python script on all of my test hardware.\nMy laptop:\n\n```bash\nupgrade@ZeroOne ~ $ uname -a\nLinux ZeroOne 4.15.0-36-generic #39~16.04.1-Ubuntu SMP Tue Sep 25 08:59:23 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\nupgrade@ZeroOne ~ $ docker run -it python:3.8 python -c 'print(\"Hello world!\")'\nHello world!\n```\n\nRaspberry Pi 4\n\n```bash\nupgrade@rpi4:~ $ uname -a\nLinux rpi4 4.19.97-v7l+ #1294 SMP Thu Jan 30 13:21:14 GMT 2020 armv7l GNU/Linux\nupgrade@rpi4:~ $ docker run -it python:3.8 python -c 'print(\"Hello world!\")'\nHello world!\n```\n\nNVIDIA Jetson Nano:\n\n```bash\nupgrade@jetson:~$ uname -a\nLinux jetson 4.9.140-tegra #1 SMP PREEMPT Mon Dec 9 22:47:42 PST 2019 aarch64 aarch64 aarch64 GNU/Linux\nupgrade@jetson:~$ docker run -it python:3.8 python -c 'print(\"Hello world!\")'\nHello world!\n```\n\nThis portability is pretty awesome - we can develop python scripts that can run on a multitude of devices without a huge hassle. And what is more important, we do not have to worry about remembering which tag runs where. This is critical if we want to develop an application that will be run by external users - no one will be interested in digging through documentation to understand which tag they should choose based on their hardware. However, there is a catch as to how to make our images work the same way.\n\n## Understanding the problem\n\nI want to start by illustrating where the \"catch\" is so that I can later show how we can correctly solve the problem.\n\nFirst thing first - we need a test subject. Time to build and test simple API that will return a hostname and equivalent of `uname -i`\n\nDocker build output:\n\n```bash\nupgrade@ZeroOne ~/src/python/multi-arch-python $ docker build -t icetekio/nodeinfo:fixedarch .\nSending build context to Docker daemon    108kB\nStep 1/5 : FROM python:3.8\n...\ntrimmed output\n...\nDigest: sha256:3df040cc8e804b731a9e98c82e2bc5cf3c979d78288c28df4f54bbdc18dbb521\n...\ntrimmed output\n...\nSuccessfully built 9185b3dffa7a\nSuccessfully tagged icetekio/nodeinfo:fixedarch\n```\n\nDocker push:\n\n```bash\nupgrade@ZeroOne ~/src/python/multi-arch-python $ docker push icetekio/nodeinfo:fixedarch\nThe push refers to repository [docker.io/icetekio/nodeinfo]\n...\ntrimmed output\n...\nfixedarch: digest: sha256:486ec9f38ecfc476e7abe911031bf8ea4a7c605716b35c490b5cf524ef0c3d12 size: 2635\n```\n\nAnd let's see how it looks on the docker hub.\n\n![architecture-of-the-nodetool-fixedarch](/blog-images/architecture-of-the-nodetool-fixedarch.png)\n\nCool! We have the image, and as you can see in my case it is _linux/amd64_ and it makes kind of sense as if you remember the output of `uname -a` on my machine was\n\n```bash\nLinux ZeroOne 4.15.0-36-generic #39~16.04.1-Ubuntu SMP Tue Sep 25 08:59:23 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n```\n\nand we need to remember that often x86_64 and amd64 are used to represent this architecture.\n\nThe quote \"The nice thing about standards is that you have so many to choose from\" from, I think, Andrew S. Tanenbaum fits here pretty nicely.\n\nNow I can run the application\n\n```bash\nupgrade@ZeroOne ~ $ docker run --name nodeinfo -it -p 8080:8080 icetekio/nodeinfo:fixedarch\n * Serving Flask app \"app\" (lazy loading)\n * Environment: production\n   WARNING: This is a development server. Do not use it in a production deployment.\n   Use a production WSGI server instead.\n * Debug mode: off\n * Running on http://0.0.0.0:8080/ (Press CTRL+C to quit)\n```\n\nand in the second terminal check if the app is working\n\n```bash\nupgrade@ZeroOne ~ $ curl localhost:8080\n{\"hostname\":\"0b31ce6600f1\",\"machine\":\"x86_64\"}\n```\n\nOK, it seems everything is going accordingly to plan.\n\nAs we know Python is very portable, and we should be able to run our simple script on multitude of architectures. Well, Python is, but our image isn't. Remember when we looked at the Docker registry? When I'm running the same command I get this nasty error.\n\nNVIDIA Jetson Nano:\n\n```bash\nupgrade@jetson:~$ docker run --name nodeinfo -it -p 8080:8080 icetekio/nodeinfo:fixedarch\nstandard_init_linux.go:211: exec user process caused \"exec format error\"\n```\n\nRaspberry Pi 4:\n\n```bash\nupgrade@rpi4:~ $ docker run --name nodeinfo -it -p 8080:8080 icetekio/nodeinfo:fixedarch\nstandard_init_linux.go:211: exec user process caused \"exec format error\"\n```\n\nTo understand better what happened we need to think about how docker builds the images. Simplifying, it takes the list of layers that are composing the base image - the `FROM python:3.8` from our example - and runs commands from Dockerfile on top of them. Every command is a new layer and then, it creates a new image manifest with the list of layers.\n\nYou can always review the layers on the Docker Hub UI. The Python image looks like this\n\n![python-image-for-amd64-architecture-details](/blog-images/python-image-for-amd64-architecture-details.png)\n\nFrom here you can learn how every image is built. As you can also see, there is an architecture dropdown and images for different architectures may be built differently. And that is why when we built our image, it took as a base a very specific image. This image was designed for AMD64 architecture and will not work on hardware that is not compatible with this architecture. And what we want to do, is to have our image behave the same way - have a dropdown and be available on a multitude of platforms.\n\n## Building on a different architecture\n\nIt is time to build the same application on my Jetson Nano and push it to the registry.\n\nRunning the build on Jetson Nano will create image that is based on ARM64 Python image, and will have the same architecture in its manifest.\n\nDocker build:\n\n```bash\nupgrade@jetson:~/multi-arch-python$ docker build -t icetekio/nodeinfo:fixedarch .\nSending build context to Docker daemon    108kB\nStep 1/5 : FROM python:3.8\n3.8: Pulling from library/python\nDigest: sha256:3df040cc8e804b731a9e98c82e2bc5cf3c979d78288c28df4f54bbdc18dbb521\nStatus: Downloaded newer image for python:3.8\n ---\u003e a42ce4e154a5\nStep 2/5 : RUN pip install Flask==1.1.2\n ---\u003e Using cache\n ---\u003e e643716e3aae\nStep 3/5 : EXPOSE 8080\n ---\u003e Using cache\n ---\u003e 74727b378afc\nStep 4/5 : ADD app.py /app.py\n ---\u003e 346527755dc5\nStep 5/5 : CMD [\"python\", \"app.py\"]\n ---\u003e Running in 47dbd9c82e10\nRemoving intermediate container 47dbd9c82e10\n ---\u003e 2ef5c195cac4\nSuccessfully built 2ef5c195cac4\nSuccessfully tagged icetekio/nodeinfo:fixedarch\n```\n\nDocker run:\n\n```bash\nupgrade@jetson:~/multi-arch-python$ docker push icetekio/nodeinfo:fixedarch\nThe push refers to repository [docker.io/icetekio/nodeinfo]\n...\ntrimmed output\n...\nfixedarch: digest: sha256:f7cf076161876b4339d08ada1db9f39f818b743ecb2a8276c4512688e179e83d size: 2635\n```\n\nI have run the same test with the `curl` command on my Jetson Nano and it works perfectly. Let's look at the Docker hub and see how the images are described now.\n\n![architecture-of-the-nodetool-fixedarch-next](/blog-images/architecture-of-the-nodetool-fixedarch-next.png)\n\nAs you can see docker has overwritten the `fixedarch` tag and now only available image is on ARM64. When I will try to run it on my laptop which is AMD64 architecture or Raspberry Pi which is on ARM32 I will get familiar errors. So, we can build images for different architectures, but how to expose them under one tag?\n\n## Manifest tool to the rescue!\n\nThere is a tool designed to resolve this problem written by Phil Estes. You can read more about it, and download it from here [https://github.com/estesp/manifest-tool](https://github.com/estesp/manifest-tool) What we need to do now is to build all 3 images with different tags and then use this tool to create a multi architecture manifest and publish it on docker hub.\n\nThe easiest way to do it, is to push all 3 images with different tags and then merge them into the same tag. I choose to use `multiarch` as a tag, and add `-arch` suffix for every architecture that I will build the image.\n\nRun the `docker build` on my laptop\n\n```bash\nupgrade@ZeroOne ~/src/python/multi-arch-python $ docker build -t icetekio/nodeinfo:multiarch-amd64 .\n...\ntrimmed output\n...\nSuccessfully tagged icetekio/nodeinfo:multiarch-amd64\n```\n\nand then `docker push`\n\n```bash\nupgrade@ZeroOne ~/src/python/multi-arch-python $ docker push icetekio/nodeinfo:multiarch-amd64\n...\ntrimmed output\n...\nmultiarch-amd64: digest: sha256:486ec9f38ecfc476e7abe911031bf8ea4a7c605716b35c490b5cf524ef0c3d12 size: 2635\n```\n\nI have repeated the process for Jetson Nano and Raspberry Pi 4, and after now we can verify images at the docker registry.\n\n![multiple-images-build-for-specific-architecture](/blog-images/multiple-images-build-for-specific-architecture.png)\n\nNow we need to create a spec file in YAML format that we will pass to `manifest-tool` to create a multi architecture manifest glueing all images into one tag.\n\nThe YAML file should look like this:\n\n```yaml\nimage: icetekio/nodeinfo:multiarch\nmanifests:\n  - image: icetekio/nodeinfo:multiarch-amd64\n    platform:\n      architecture: amd64\n      os: linux\n\n  - image: icetekio/nodeinfo:multiarch-arm32\n    platform:\n      architecture: arm\n      os: linux\n\n  - image: icetekio/nodeinfo:multiarch-arm64\n    platform:\n      architecture: arm64\n      os: linux\n```\n\nNotice, that the architecture for ARM32 bit is actually `arm`. The values in manifest need to correspond to the values found in docker registry.\n\nAnd now for the final step!\n\n```bash\nupgrade@ZeroOne ~/src/python/multi-arch-python $ manifest-tool --debug push from-spec manifest.yaml\nDEBU[0000] endpoints: [{false https://registry-1.docker.io v2 false true true 0xc000346600}]\nDEBU[0000] repoName: icetekio/nodeinfo\nINFO[0000] Retrieving digests of images...\nDEBU[0000] authConfig for docker.io: mrupgrade\nDEBU[0000] endpoints: [{false https://registry-1.docker.io v2 false true true 0xc000346780}]\nDEBU[0000] Trying to fetch image manifest of docker.io/icetekio/nodeinfo repository from https://registry-1.docker.io v2\nINFO[0002] Image \"icetekio/nodeinfo:multiarch-amd64\" is digest sha256:486ec9f38ecfc476e7abe911031bf8ea4a7c605716b35c490b5cf524ef0c3d12; size: 2635\nDEBU[0002] authConfig for docker.io: mrupgrade\nDEBU[0002] endpoints: [{false https://registry-1.docker.io v2 false true true 0xc000542d80}]\nDEBU[0002] Trying to fetch image manifest of docker.io/icetekio/nodeinfo repository from https://registry-1.docker.io v2\nINFO[0005] Image \"icetekio/nodeinfo:multiarch-arm32\" is digest sha256:c9ab7b7cd3c7b89bc611ce56368d6a4cbc6c27040e485839410e9c1ae8d4c9bf; size: 2635\nDEBU[0005] authConfig for docker.io: mrupgrade\nDEBU[0005] endpoints: [{false https://registry-1.docker.io v2 false true true 0xc000346f00}]\nDEBU[0005] Trying to fetch image manifest of docker.io/icetekio/nodeinfo repository from https://registry-1.docker.io v2\nINFO[0008] Image \"icetekio/nodeinfo:multiarch-arm64\" is digest sha256:f7cf076161876b4339d08ada1db9f39f818b743ecb2a8276c4512688e179e83d; size: 2635\nDEBU[0008] Manifest list push url: https://registry-1.docker.io/v2/icetekio/nodeinfo/manifests/multiarch\nDEBU[0008] mediaType of manifestList: application/vnd.docker.distribution.manifest.list.v2+json\nDEBU[0008] authConfig for docker.io: mrupgrade\nDigest: sha256:7eb4667ada05d0bc64686080c7dbc80edb1adf2405f7061db386df61e5ad778a 1050\n```\n\nSuccess!\n\n![one-image-supporting-all-three-architectures](/blog-images/one-image-supporting-all-three-architectures.png)\n\nSo now we know how to build images that users can use seamlessly on multiple architectures. Now this small app can run on all 3 devices and there is no need to worry about which tag to use - simply use the `multiarch` tag!\n\n## Final thoughts\n\nThere is a lot more to preparing applications to run on every platform. In this example we used Python which by itself is portable. Most of the Python code can run anywhere without needing to port anything, and usually the only thing that user have to worry about is having Python interpreter available. Applications in other languages - especially the compiled ones - need to be written with portability in mind - and built on a given machine. Sometimes - like with Golang for example - the compiler offers cross compilation. Building applications on multiple architectures is actually massive topic, and I will try to cover more aspects of it, including how Docker can be used to help with this process in future articles.\n\nIf you are interested reading about my failures and lessons learned when I first try to port my application to ARM architecture you can read my Medium post found here [https://medium.com/icetek/porting-iceci-to-arm-1d44850ef03f](https://medium.com/icetek/porting-iceci-to-arm-1d44850ef03f)\n\n## Readout\n\nMulti architecture announcement on Docker blog: [https://www.docker.com/blog/docker-official-images-now-multi-platform/](https://www.docker.com/blog/docker-official-images-now-multi-platform/)\n\nBlog post about multi architecture functionalities in docker: [https://www.docker.com/blog/multi-arch-all-the-things/](https://www.docker.com/blog/multi-arch-all-the-things/)\n\nManifest tool GitHub repository: [https://github.com/estesp/manifest-tool](https://github.com/estesp/manifest-tool)\n\nIoT and Edge are pretty hot topics, so it's no wonder that many applications run on both ARM and x86 architectures. While dockerizing multiplatform applications it's a good idea to prepare multiplatform-aware images as well, as it can simplify a lot of things down the line and implementing this shouldn't introduce too much overhead. Jakub has prepared a write-up on building a multi-architecture image for a PC, NVIDIA Jetson Nano and a Raspberry Pi, you can check it out on our blog.\n"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"understanding-how-docker-multi-arch-images-work"},"buildId":"qXuR2Q6U2o4nVcHdlp6Hy","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body><script defer="" src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script><script defer="" src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script><script defer="" src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script></html></body></html>