{"pageProps":{"data":{"author":"Dominik Andruszak","authorPhoto":"dominik-andruszak.jpeg","date":"2020-03-31T07:50:39Z","image":"new-header-img.png","slug":"new-in-kubernetes-1-18-kubectl-alpha-debug","summary":"Is it useful? What prolems can it help solve?","title":"New in Kubernetes 1.18 — kubectl alpha debug"},"slug":"new-in-kubernetes-1-18-kubectl-alpha-debug","content":"\nKubernetes 1.18 has just landed and, as always, a couple of existing features got stabilized and a couple of new ones have been introduced. Let's take gander at one of the newest additions - `kubectl alpha debug`. This nifty `kubectl` feature gives you an additional tool for debugging pods when `kubectl exec` just doesn't cut it. Most probably your application-hosting containers won't have all the necessary debugging tools - they might not even have a shell. The `kubectl alpha debug` features allows you to create a temporary container inside your pod - and that container can have all the tools that you need.\n\n## So... how does it work?\n\n`kubectl alpha debug` utilizes ephemeral containers - a kind of temporary container that can be added while the pod is running. Ephemeral containers are built for debugging purposes only - they have a stripped down spec compared to base pod containers and they're not really suitable for hosting applications. The feature is still in alpha and has to be enabled through a feature gate. You can read more about ephemeral containers in the Kubernetes documentation [https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/](https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/)\n\n## How do I get in?\n\nFirst, we have to make sure that we have version 1.18 for both the Kubernetes server and client. Even though ephemeral containers were introduced in Kubernetes 1.16, using `kubectl` 1.18 with Kubernetes 1.16 didn't seem to work properly in my cluster.\n\n```yaml\n$ kubectl version\nClient Version: version.Info{Major:\"1\", Minor:\"18\", GitVersion:\"v1.18.0\", GitCommit:\"9e991415386e4cf155a24b1da15becaa390438d8\", GitTreeState:\"clean\", BuildDate:\"2020-03-25T14:58:59Z\", GoVersion:\"go1.13.8\", Compiler:\"gc\", Platform:\"linux/amd64\"}\nServer Version: version.Info{Major:\"1\", Minor:\"18\", GitVersion:\"v1.18.0\", GitCommit:\"9e991415386e4cf155a24b1da15becaa390438d8\", GitTreeState:\"clean\", BuildDate:\"2020-03-25T14:50:46Z\", GoVersion:\"go1.13.8\", Compiler:\"gc\", Platform:\"linux/amd64\"}\n```\n\nWe also have to enable ephemeral containers through a feature gate - in my examples, I'll be using Minikube.\n\n```yaml\n$ minikube config set feature-gates EphemeralContainers=true\n❗  These changes will take effect upon a minikube delete and then a minikube start\n```\n\nOnce the Minikube cluster is recreated, we're pretty much good to go. Let's create a simple pod and see what we can do.\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: simple\nspec:\n  containers:\n    - image: alpine\n      name: simple\n      command:\n        - \"/bin/sh\"\n        - \"-c\"\n        - \"sleep 5000\"\n```\n\n```bash\n$ kubectl apply -f simple.yaml\npod/simple created\n```\n\nOnce the pod is up and running we can hop into it using the debug command. Please remember that the container image might have to download and the whole command might seem stuck for a while (there's not visible indication of the download happening)\n\n```bash\n$ kubectl alpha debug -it simple --image=ubuntu --target=simple --container=debug\nIf you don't see a command prompt, try pressing enter.\nroot@simple:/#\n```\n\nLet's go through the parameters that we've passed to this command:\n\n- `-it` might look familliar and for a good reason - those two parameters are responsible for keeping the `stdin` open and allocating a TTY\n- `--image` is the name of an image for the ephemeral container - it doesn't have to match the main container's image; in this example we're using `ubuntu` even though the main container is running `alpine`\n- `--container` is the name of the ephemeral container itself\n- `--target` lets the ephemeral container share a process namespace with a container inside the pod - we'll get back to that in a second\n\nThose params are also reflected in the updated spec of the `simple` pod in the cluster (the output is trimmed to just show the interesting part)\n\n```bash\n$ kubectl get po simple -o yaml\n(...)\nephemeralContainers:\n  - image: ubuntu\n    imagePullPolicy: IfNotPresent\n    name: debug\n    resources: {}\n    stdin: true\n    targetContainerName: simple\n    terminationMessagePolicy: File\n    tty: true\n(...)\n```\n\n## What's in the box?\n\nSince we're attached to the debug container, let's have a look around.\n\n```bash\nroot@simple:/# pwd\n/\nroot@simple:/# ls\nbin   dev  home  lib64  mnt  proc  run   srv  tmp  var\nboot  etc  lib   media  opt  root  sbin  sys  usr\nroot@simple:/# whoami\nroot\nroot@simple:/# cat /etc/*-release\nDISTRIB_ID=Ubuntu\nDISTRIB_RELEASE=18.04\nDISTRIB_CODENAME=bionic\nDISTRIB_DESCRIPTION=\"Ubuntu 18.04.4 LTS\"\nNAME=\"Ubuntu\"\nVERSION=\"18.04.4 LTS (Bionic Beaver)\"\nID=ubuntu\nID_LIKE=debian\nPRETTY_NAME=\"Ubuntu 18.04.4 LTS\"\nVERSION_ID=\"18.04\"\nHOME_URL=\"https://www.ubuntu.com/\"\nSUPPORT_URL=\"https://help.ubuntu.com/\"\nBUG_REPORT_URL=\"https://bugs.launchpad.net/ubuntu/\"\nPRIVACY_POLICY_URL=\"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\"\nVERSION_CODENAME=bionic\nUBUNTU_CODENAME=bionic\n```\n\nWe've added a new `ubuntu` container to an existing pod (which was already running an `alpine` ontainer) on the fly, pretty neat! So what can we do now? Well, for example, we can install and use tools like `nslookup` to debug and verify the pod networking and network policies.\n\n```bash\nroot@simple:/# nslookup google.com\nServer:\t\t10.96.0.10\nAddress:\t10.96.0.10#53\n\nNon-authoritative answer:\nName:\tgoogle.com\nAddress: 172.217.16.14\nName:\tgoogle.com\nAddress: 2a00:1450:401b:804::200e\n```\n\nWhat's a bit more interesting - remember that `--target` parameter that we've passed to `kubectl alpha debug`? If we set its value to the name of our main container, it will share its process namespace ([https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/](https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/)) with the ephemeral container. This means that our `debug` container sees all processes created by `simple`.\n\n```bash\nroot@simple:/# ps aux\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.0  0.0   1568     4 ?        Ss   08:47   0:00 sleep 5000\nroot         6  0.0  0.0  18504  3500 pts/0    Ss   08:48   0:00 /bin/bash\nroot       467  0.0  0.0  34400  2904 pts/0    R+   08:54   0:00 ps aux\nroot@simple:/# head -n 3 /proc/1/status\nName:\tsleep\nUmask:\t0022\nState:\tS (sleeping)\n```\n\nLet's try a different pod - a bit more complex this time around.\n\n```bash\napiVersion: v1\nkind: Pod\nmetadata:\n  name: complex\nspec:\n  containers:\n  - image: alpine\n    name: complex\n    env:\n    - name: ENV_FIRST\n      value: first\n    - name: ENV_SECOND\n      value: second\n    volumeMounts:\n    - name: my-volume\n      mountPath: /tmp/fromVolume\n    command:\n    - \"/bin/sh\"\n    - \"-c\"\n    - \"echo \\\"Hello world\\\" > /tmp/echoed && echo \\\"Hello volume\\\" > /tmp/fromVolume/echoed && sleep 5000\"\n  volumes:\n  - name: my-volume\n    emptyDir: {}\n```\n\nOnce it's created, let's jump right into the pod with a new debug container. As before, we can check out the main container processes.\n\n```bash\n$ kubectl apply -f complex.yaml\npod/complex created\n$ kubectl alpha debug -it complex --image=ubuntu --target=complex --container=debug\nIf you don't see a command prompt, try pressing enter.\nroot@complex:/# ps aux\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.0  0.0   1568     4 ?        Ss   09:06   0:00 sleep 5000\nroot         6  0.1  0.0  18504  3388 pts/0    Ss   09:06   0:00 /bin/bash\nroot        16  0.0  0.0  34400  2792 pts/0    R+   09:06   0:00 ps aux\n```\n\nWe can peek some of the resources used by that process as well, like files - both those created on the container's ephemeral storage, as well as those created on a volume.\n\n```bash\nroot@complex:/# head /proc/1/root/tmp/echoed\nHello world\nroot@complex:/# head /proc/1/root/tmp/fromVolume/echoed\nHello volume\n```\n\nWe can also check out the environment variables - the original output isn't too human-friendly, I've reformatted it here for clarity.\n\n```bash\nroot@complex:/# head /proc/1/environ\nKUBERNETES_PORT=tcp://10.96.0.1:443\nKUBERNETES_SERVICE_PORT=443\nHOSTNAME=complex\nENV_SECOND=second\nSHLVL=1\nHOME=/root\nKUBERNETES_PORT_443_TCP_ADDR=10.96.0.1\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nKUBERNETES_PORT_443_TCP_PORT=443\nKUBERNETES_PORT_443_TCP_PROTO=tcp\nENV_FIRST=first\nKUBERNETES_SERVICE_PORT_HTTPS=443\nKUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443\nKUBERNETES_SERVICE_HOST=10.96.0.1\nPWD=/\n```\n\nFinally, let's see what happens when the main container inside the pod keeps crashing and restarting - let's simulate this with a simple pod.\n\n```bash\napiVersion: v1\nkind: Pod\nmetadata:\n  name: crash\nspec:\n  containers:\n  - image: alpine\n    name: crash\n    command:\n    - \"/bin/sh\"\n    - \"-c\"\n    - \"sleep 3 && whatisthis\"\n```\n\nWhen we try to attach to the pod inside the container, the command seems to be stuck.\n\n```bash\n$ kubectl apply -f crash.yaml\npod/crash created\n$ kubectl alpha debug -it crash --image ubuntu --target=crash --container=debug\n```\n\nThat's actually true, a quick look into the pod describe reveals that our `debug` container cannot be created, becase the main container isn't running. Does that mean that it's not possible to debug the pod? Au contraire, we can still do it - just without the `--target` parameter. This still allows us to debug pod networking, for example.\n\n```bash\n$ kubectl alpha debug -it crash --image ubuntu --container=debug-no-target\nIf you don't see a command prompt, try pressing enter.\nroot@crash:/# ps aux\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.2  0.0  18504  3300 pts/0    Ss   09:19   0:00 /bin/bash\nroot        10  0.0  0.0  34400  2900 pts/0    R+   09:19   0:00 ps aux\n```\n\n## Final thoughts\n\nWhile still in it's early stage, `kubectl alpha debug` shapes up to be a useful and potentially powerful tool. There are a couple use cases in which it might become really handy. Many of the containers running applications might not even have a shell, which renders `kubectl exec` unusable - the new debug feature allows for jumping into the pod without needing to change its manifest and recreating it. Even if a shell is available, the application containers most probably don't have all the tools necessary for debugging - and we might not want to install them manually inside a running container. With `kubectl alpha debug` we can create an kind of a \"tool belt\" image containing all the utilities that we use for debugging - and then simple create an ephemeral container in pods that have issues. Possibly it might even be used for attaching remote debuggers to applications running in pods.\n\nAll in all, `kubectl alpha debug` is a very interesting feature, looking forward to see how it evolves in future releases.\n"},"__N_SSG":true}